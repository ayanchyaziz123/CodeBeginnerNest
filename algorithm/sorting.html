<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demystifying Sorting Algorithms</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
        }

        h1 {
            color: #333;
        }

        h2 {
            color: #444;
        }

        p {
            color: #666;
        }

        code {
            font-family: 'Courier New', monospace;
            background-color: #f2f2f2;
            padding: 5px;
            border-radius: 3px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }
    </style>
</head>

<body>

    <h3>Demystifying Sorting Algorithms</h3>

    <p>Welcome to our blog post on sorting algorithms! Sorting is a fundamental operation in computer science, and there
        are various algorithms designed to efficiently arrange elements in a specific order. Let's explore some
        popular sorting algorithms and understand their time complexity.</p>

    <h2>1. Bubble Sort</h2>

    <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements,
        and swaps them if they are in the wrong order.</p>

    <code>
        def bubble_sort(arr):
        <br>&nbsp;&nbsp;&nbsp;&nbsp;n = len(arr)
        <br>&nbsp;&nbsp;&nbsp;&nbsp;for i in range(n):
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j in range(0, n-i-1):
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if arr[j] > arr[j+1]:
        <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j], arr[j+1] = arr[j+1], arr[j]
                
    </code>

    <h2>2. Selection Sort</h2>

    <p>Selection Sort sorts an array by repeatedly finding the minimum element from the unsorted part of the array and
        putting it at the beginning.</p>

    <code>
        def selection_sort(arr):
            n = len(arr)
            for i in range(n):
                min_index = i
                for j in range(i+1, n):
                    if arr[j] < arr[min_index]:
                        min_index = j
                arr[i], arr[min_index] = arr[min_index], arr[i]
    </code>

    <h2>3. Insertion Sort</h2>

    <p>Insertion Sort builds the final sorted array one item at a time. It is much less efficient on large lists than
        more advanced algorithms such as quicksort, heapsort, or merge sort.</p>

    <code>
        def insertion_sort(arr):
            for i in range(1, len(arr)):
                key = arr[i]
                j = i - 1
                while j >= 0 and key < arr[j]:
                    arr[j + 1] = arr[j]
                    j -= 1
                arr[j + 1] = key
    </code>

    <h2>4. Merge Sort</h2>

    <p>Merge Sort is an efficient, stable, and comparison-based sorting algorithm. Most implementations produce a
        stable sort, meaning that the implementation preserves the input order of equal elements in the sorted
        output.</p>

    <code>
        def merge_sort(arr):
            if len(arr) > 1:
                mid = len(arr) // 2
                left_half = arr[:mid]
                right_half = arr[mid:]

                merge_sort(left_half)
                merge_sort(right_half)

                i = j = k = 0

                while i < len(left_half) and j < len(right_half):
                    if left_half[i] < right_half[j]:
                        arr[k] = left_half[i]
                        i += 1
                    else:
                        arr[k] = right_half[j]
                        j += 1
                    k += 1

                while i < len(left_half):
                    arr[k] = left_half[i]
                    i += 1
                    k += 1

                while j < len(right_half):
                    arr[k] = right_half[j]
                    j += 1
                    k += 1
    </code>

    <h2>5. Quick Sort</h2>

    <p>Quick Sort is a widely used sorting algorithm known for its efficiency in practice. It is an in-place sorting
        algorithm that uses a divide-and-conquer strategy to partition the array into segments.</p>

    <code>
        def quick_sort(arr, low, high):
            if low < high:
                pivot_index = partition(arr, low, high)
                quick_sort(arr, low, pivot_index - 1)
                quick_sort(arr, pivot_index + 1, high)

        def partition(arr, low, high):
            pivot = arr[high]
            i = low - 1

            for j in range(low, high):
                if arr[j] <= pivot:
                    i += 1
                    arr[i], arr[j] = arr[j], arr[i]

            arr[i + 1], arr[high] = arr[high], arr[i + 1]
            return i + 1
    </code>

    <h2>Sorting Algorithm Time Complexity</h2>

    <p>Here's a comparison of the time complexity of common sorting algorithms:</p>

    <table>
        <tr>
            <th>Algorithm</th>
            <th>Time Complexity (Average Case)</th>
        </tr>
        <tr>
            <td>Bubble Sort</td>
            <td>O(n^2)</td>
        </tr>
        <tr>
            <td
